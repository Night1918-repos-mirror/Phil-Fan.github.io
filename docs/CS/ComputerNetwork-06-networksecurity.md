# 网络安全

## 数论前置知识

### 同余 (Congruence)

同余是表示两个整数除以同一个正整数后余数相等的关系。如果整数 $a$ 除以正整数 $n$ 的余数与整数$b$除以$n$的余数相同，我们说$a$和$b$对模$n$同余，表示为：

$$
a \equiv b \mod n
$$

### 互质 (Coprime)

$$
gcd(a, b) = 1
$$

### 欧拉函数 (Euler's Totient Function)

欧拉函数$\phi(n)$是小于或等于$n$的正整数中与$n$互质的数的数量。

对于质数$p$，$\phi(p) = p - 1$。如果$n$是两个不同质数$p$和$q$的乘积，即$n = pq$，那么$\phi(n) = (p-1)(q-1)$。

$$
\phi(n) = n \prod_{p|n} \left(1 - \frac{1}{p}\right)
$$

### 欧拉定理

欧拉定理指出，对于两个互质的正整数 \(a\) 和 \(n\)（即 \(gcd(a, n) = 1\)），\(a\) 的欧拉函数 \(\phi(n)\) 次幂对 \(n\) 的模等于 1。用数学表达式表示为：

$$
a^{\phi(n)} \equiv 1 \mod n
$$

其中，\(\phi(n)\) 是欧拉函数，表示小于或等于 \(n\) 的正整数中与 \(n\) 互质的数的数量。

### 模逆 (Modular Inverse)

如果存在整数$b$使得$ab \equiv 1 \mod n$，则称$b$是$a$模$n$的逆元

$$
a^{-1} \equiv b \mod n
$$

表示找到一个数$b$，使得$a$和$b$相乘对模$n$同余1。

## 加密

![image-20240215231126309](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240215231126309.png)

- Trudy: 窃听、插入、伪装、劫持、拒绝服务

只有发送方和预订的接收方能否理解传输的报文内容
发送方加密报文；接收方解密报文



### 对称加密

加密解密密钥一样

- 字母替换，通过分析字频和词频可以破解

$K_{A-B}$:对称密钥

密钥的分发：密码本



#### DES |  `Data Encryption Standard`

- US 加密标准[NIST 1993]
- 56-bit 对称密钥, 64-bit明文输入
- 破解很难，但是可能有后门
- 使DES更安全：
  - 使用3个key，3重DES 运算；
  - 密文分组成串技术：当前明文和前面密文64bit 做异或处理

#### AES | `Advanced Encryption Standard`

- 新的对称密钥NIST标准(Nov. 2001) 用于替换DES

- 数据128bit成组加密：128, 192, or 256 bit keys

- 穷尽法解密如果使用1秒钟破解DES, 需要花149万亿年破解AES





密码块：如果输入块重复，将会得到相同的密文块
 密码块链： 异或第i轮输入m(i), 与前一轮的密文, c(i-1)  c(0) 明文传输到接收端

### 非对称密钥加密：

RSA: `Rivest, Shamir, Adelson algorithm`

两个密钥不一样

公钥公开：证书方式

私钥：自己保留



加密

> 我给你一把锁，钥匙只有我自己拿着，你把东西用我的锁锁起来

数字签名

> 使用私钥进行盖章，就知道这个锁是来源是谁了





RSA算法过程

将两个大质数相乘是容易的，但是要将其乘积分解回原来的两个质数却极其困难。

1. 选择两个大质数 $p$ 和 $q$。
2. 计算它们的乘积 $n = pq$，$n$ 的长度就是密钥长度。
3. 计算 $n$ 的欧拉函数 $\phi(n) = (p-1)(q-1)$
4. 选择一个整数 $e$，使得 $e$ 与 $\phi(n)$ 互质，且 $1 < e < \phi(n)$。通常，$e$ 被选为65537。
5. 计算 $e$ 相对于 $\phi(n)$ 的模逆 $d$，即满足 $ed \equiv 1 \mod \phi(n)$ 的 $d$。

加密: 

$$
C = M^e \mod n
$$

解密: 

$$
M = C^d \mod n
$$

证明目标: 显示解密操作确实恢复了原始消息 $M$。 

证明过程: 

1. 根据欧拉定理，如果 $gcd(M, n) = 1$，则 $M^{\phi(n)} \equiv 1 \mod n$。 
2. $ed = 1 + k\phi(n)$ 表示 $e$ 和 $d$ 是模 $\phi(n)$ 的乘法逆元
3. 因此，$M^{ed} = M^{1+k\phi(n)} = M \cdot (M^{\phi(n)})^k$。 由于 $M^{\phi(n)} \equiv 1 \mod n$，我们得到 $M^{ed} \mod n = M \mod n$，这证明了解密后我们可以得到原始消息 $M$。

<img src="https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240216123200169.png" alt="image-20240216123200169" style="zoom:50%;" />





## 认证

发送方和接收方需要确认对方的身份

认证目的：避免重放攻击

Nonce: 一生只用一次的整数(R)



ap4.0: 对称密钥加密

为了证明Alice的活跃性, Bob发送给Alice一个nonce,

R. Alice 必须返回加密之后的R，使用双方约定好的key

问题：如何分发对称式加密的密钥



ap5.0：非对称密钥加密

Bob发送challenge R，Alice发送私钥加密的报文和公钥，bob解密

漏洞：Trudy中间截获所有，`middle attack`

原因：不能可靠地拿到Alice的公钥



## 报文完整性

发送方、接受方需要确认报文在传输的过程中或者事后没有被改变



数字签名类比于手写签名

可验证性（对接收方），不可伪造性（对发送方），不可抵赖性（对第三方）



报文m 报文摘要H(m)

计算报文摘要的签名$K^-_B(H(m))$



报文摘要：互异、反向计算特别难

> 一车水果打成果汁，取1mL果汁进行签名，足以代表一车水果

MD5散列函数 - 四个步骤计算出128bit摘要

SHA-1 - 160bit报文摘要（git使用）

SHA-256





公钥机制也有它的缺点，那就是**效率非常低**

所以使用公私钥算法结合的方法

用非对称算法对 对称密钥进行加密，明文使用对称密钥进行加密

- 私钥用来进行解密和签名，是给自己用的。
- 公钥由本人公开，用于加密和验证签名，是给别人用的。
- 当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。



## 密钥分发与证书

可信赖中介

### 对称式解决 | KDC **Key Distribution Center**

为“密钥分发中心”。它是网络安全和加密通信中使用的一个中央服务器，负责分发网络中各方之间通信所需的密钥。

KDC是Kerberos认证协议中的核心组件，主要用于认证服务和分配对称密钥，以确保网络中的数据传输安全。



- 与KDC先建立起可信赖的对话关系
- KDC生成对称密钥

1. **认证请求**：用户客户端向KDC的认证服务请求认证，通常包括用户的ID和所请求服务的ID。 
2. **TGT发放**：KDC验证用户的凭证（如密码）。如果验证成功，KDC会发放一个票据授权票据（Ticket Granting Ticket, TGT），加密包含用户的权限信息，使用KDC的密钥加密。 
3. **服务票据请求**：当用户需要访问服务时，客户端使用TGT向KDC请求针对特定服务的服务票据（Service Ticket）。 
4. **服务票据发放**：KDC验证TGT，并且如果用户有权限访问请求的服务，KDC会发放一个服务票据，该票据使用服务的密钥加密，包含用户的身份信息。 
5. **服务访问**：用户客户端使用服务票据向服务进行认证。服务解密服务票据，验证用户的权限，然后允许访问。 
6. **通信加密**：客户端和服务之间的通信可以使用从KDC获得的会话密钥加密，确保数据传输的安全性。 

![image-20240216132053873](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240216132053873.png)





### 非对称解决 | CA Certification Authorities

出厂自带CA的公钥

用CA的私钥签署了$$CA^-(Bob,K_B^+)$$

![image-20240217100652773](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240217100652773.png)

- 串号(证书发行者唯一)
- 证书拥有者信息，包括算法和密钥值本身(不显示出来
- 证书发行者信息
- 有效日期
- 颁发者签名



根证书：根证书是未被签名的公钥证书或自签名的证书
 拿到一些CA的公钥
 渠道：安装OS自带的数字证书；从网上下载，你信任的数字证书



信任树：

- 信任了根
- 由根CA签署的给一些机构的数字证书，根信任机构
- 由于你信任了根，从而能够可靠地拿到根CA签发的证书，可靠地拿到这些机构的公钥

- 

## 安全场景

### HTTP 认证

#### 基本认证

当一个客户端向 HTTP 服务器进行数据请求时，如果客户端未被认证，则 HTTP 服务器将通过基本认证过程对客户端的用户名及密码进行验证，以决定用户是否合法。

客户端在接收到 HTTP 服务器的身份认证要求后，会提示用户输入用户名及密码，然后将用户名及密码以`BASE64`加密，加密后的密文将附加于请求信息中。

> 如当用户名为`anjuta`，密码为：`123456`时，客户端将用户名和密码用“：”合并，并将合并后的字符串用`BASE64`加密为密文，并于每次请求数据时，将密文附加于请求头（Request Header）中

HTTP 服务器在每次收到请求包后，根据协议取得客户端附加的用户信息（`BASE64`加密的用户名和密码），解开请求包，对用户名及密码进行验证

BASIC 认证的步骤：

1. 客户端访问一个受 HTTP 基本认证保护的资源；

2. 服务器返回 `401` 状态，要求客户端提供用户名和密码进行认证。（验证失败的时候，响应头会加上`WWW-Authenticate: Basic realm="请求域"`），如下所示：

   ```
   401 Unauthorized
   WWW-Authenticate： Basic realm="WallyWorld"
   ```

3. 客户端将输入的用户名密码用`Base64`进行编码后，采用非加密的明文方式传送给服务器；

   ```
   Authorization: Basic xxxxxxxxxx.
   ```

4. 服务器将 `Authorization` 头中的用户名密码解码并取出，进行验证，如果认证成功，则返回相应的资源；如果认证失败，则仍返回 `401` 状态，要求重新进行认证。



#### 摘要认证 digest authentication

该认证是 HTTP1.1 提出的基本认证的替代方法，不包含密码的明文传递。 摘要认证使用`随机数 + MD5 加密哈希函数`来对用户名、密码进行加密，在上述第二步时，服务器返回随机字符串 `nonnce` 之后，客户端发送摘要`MD5（HA1:nonce:HA2）`。 其中`HA1=MD5(username:realm:password),HA2=MD5(method:digestURI)`。

#### 开放认证 OAuth Authentication

开放认证允许用户提供一个令牌，而不是用户名和密码来访问它们存放在特定服务器的数据，每一个令牌授权一个特定的第三方系统。

#### 令牌认证 Token Authentication

令牌认证是指当用户第一次登陆时，服务器生成一个 token 并返回给客户端，之后的每次访问客户端都会带上该 token，无需再次带上用户名和密码。

#### 基本认证中的认证相关字段

（1）服务器响应状态码与状态描述：当服务器响应状态码为 401 时，表明服务器资源需要认证。 其状态描述为`Unauthorized`，表明未通过认证，当响应`200 OK`时，表明通过认证，正常响应； 

（2）当用户提供用户名和密码后，重新提出请求时：  ` Authorization: Basic xxxxxxxxxx. ` `Authorization` 字段表明在请求中，提供了需要的认证方式和认证信息（已经经过加密）。



### 安全电子邮件

私密性：对称式+非对称式

可认证性和报文完整性：传报文和数字签名（用对称式密钥加密），密钥用对方公钥加密；

​	如果接收方bob算出的报文摘要和传过来的报文摘要是相同的

PGP 电子邮件加密方案

应用层

![image-20240217101521016](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240217101521016.png)

<img src="https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240217101539896.png" alt="image-20240217101539896" style="zoom: 67%;" />

### SSL (secure sockets layer)

为使用SSL服务的、基于TCP的应用提供传输层次的安全性

步骤

- 握手
- 密钥导出
- 数据传输

传输层



### IPsec

网络层

双方要建立通信关系

Authentication Header (AH) 协议

提供源端的可认证性，数据完整性，但是不提供机密性



ESP 协议

提供机密性，主机的可认证性，数据的完整性



### 802.11 security

链路层的安全





## 运行中的安全性

### 手段

#### 病毒 virus

计算机病毒是一种计算机程序，它在执行时将自己附于其他程序或文件并编写其自己的代码，从而能够从一个程序传播到另一个程序，并在传播过程中感染计算机。

几乎所有的计算机病毒都附于一个可执行文件，**不点击不感染**！

#### 蠕虫 worm

**自我复制！独立运行！**

蠕虫在设计上类似于计算机病毒，但它是病毒或特洛伊木马程序的一个子类别。

然而与病毒不同的是，它能够在不附于主机程序的情况下传播，并且可以独立运行。

蠕虫利用了系统中的文件或信息传输功能，使其能在无帮助的情况下传播。其结果是蠕虫消耗了太多的系统内存（或网络带宽），从而导致Web服务器、网络服务器和个人的计算机停止响应。

> 一个例子是蠕虫向您的电子邮件地址簿列出的每个人发送其副本。然后，蠕虫继续自我复制并将自己发送给每个收件人的地址簿列出的每个人，并继续重复此过程.

#### 木马

特洛伊木马程序是指让用户误解其意图的各类恶意软件，例如看似是正版应用程序或软件程序但实际是破坏性程序。

特洛伊木马程序是根据古希腊神话中特洛伊木马的故事所命名的，特洛伊木马具有欺骗性，它摧毁了特洛伊城。与病毒不同，特洛伊木马程序不会自我复制，但它们同样具有破坏性。特洛伊木马还能打开计算机的后门，向恶意分子发出命令，或能让恶意用户/程序访问您的系统。这会导致机密信息和个人信息被盗。

### 攻击

- 加密算法已知，求密钥
- 加密算法和密钥均不知道
- 唯密文攻击
- 已知明文攻击
- 已经知道部分密文和明文的对应关系
- 选择明文攻击
- 攻击者能够选择一段明文，并得到密文

### 防火墙

将组织内部网络和互联网络隔离开来，按照规则进行分组过滤

防火墙在网络层



1.阻止拒绝服务攻击(DOS deny of service,DDOS distributive)：

SYN flooding: 攻击者建立很多伪造TCP链接，对于真正用户而言已经没有资源留下了

阻止非法的修改/对非授权内容的访问

2.只允许认证的用户能否访问内部网络资源(经过认证的用户/主机集合)

- 2种类型的防火墙:
  - 网络级别：分组过滤器
  - 应用级别：应用程序网关



规则

- 源IP地址,目标IP地址
- TCP/UDP源和目标端口
- ICMP报文类别
- TCP SYN 和ACK bits



#### 无状态规则

防火墙不维持通讯状态

| 策略                                                         | 设置                                                      |
| ------------------------------------------------------------ | --------------------------------------------------------- |
| 所有的进出UDP流以及telnet 连接的数据报都被阻塞掉             | 只要拥有IP协议字段= 17，<br/>而且源/目标端口号= 23.       |
| 阻止外部客户端和内部网络的主机建立TCP连接<br/>但允许内部网络的客户端和外部服务器建立TCP连接 | 阻塞进入内网的TCP段：它的ACK=0.                           |
| 不允许外部的web进行访问                                      | 阻塞掉所有外出具有目标端口80的IP分组                      |
| 不允许来自外面的TCP连接，除非是机构公共WEB服务器的连接       | 阻塞掉所有进来的TCP SYN分组，除非130.207.244.203, port 80 |
| 阻止Web无线电占用可用带宽.                                   | 阻塞所有进来的UDP分组 除非DNS 和路由器广播                |
| 阻止你的网络被`smurf DoS`所利用                              | 阻塞掉所有具有广播地址的ICMP分组(eg130.207.255.255).      |
| 阻止内部网络被`tracerout`，从而得到你的网络拓扑              | 阻塞掉所有外出的ICMP TTL过期的流量                        |



#### 有状态规则

无状态分组过滤根据每个分组独立地检查和行动
有状态的分组过滤联合分组状态表检查和行动



知道连接后，才不被block掉；防火墙知道是否已经进行连接

防火墙变成了状态维护的设备



#### ACL `access control list`

最后一条规则，默认规则匹配所有



根据应用数据的内容来过滤进出的数据报，就像根据IP/TCP/UDP字段来过滤一样
 检查的级别：应用层数据

对应用进行深度剖析

<img src="https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240217110805828.png" alt="image-20240217110805828" style="zoom:50%;" />

`IP spoofing`: 路由器不知道数据报是否真的来自于声称的源地址

更改IP的头部字段

对UDP要么全过，要么全不过



**折中: 与外部通信的自由度，安全的级别**



### 入侵检测系统 IDS intrusion detection system

multiple IDSs: 在不同的地点进行不同类型的检查

<img src="https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240217111255212.png" alt="image-20240217111255212" style="zoom:50%;" />

在所有流量上放置sensor

- 深入分组检查: 检查分组的内容(e.g., 检查分组中的特征串已知攻击数据库的病毒和攻击串

- 检查分组间的相关性，判断是否是有害的分组

  • 端口扫描
  • 网络映射
  • DoS 攻击



映射:
 在攻击之前： “踩点” – 发现在网络上实现了哪些服务
 使用ping来判断哪些主机在网络上有地址
 端口扫描：试图顺序地在每一个端口上建立TCP连接(看看发生了什么)



分组嗅探: 对策
 机构中的所有主机都运行能够监测软件，周期性地检查是否有网卡运行于**混杂模式**
 每一个主机一个独立的网段(交换式以太网而不是使用集线器)



IP Spoofing欺骗:
 可以有应用进程直接产生“raw” IP分组, 而且可以在IP源地址部分直接放置任何地址
 接收端无法判断源地址是不是具有欺骗性的
 e.g. C 伪装成B

设置入口过滤，出去的分组源IP应该和这个网段一致



Denial of service (DOS): 对策
 在到达主机之前过滤掉这些泛洪的分组(e.g., SYN): throw out good with bad
 回溯到源主机(most likely an innocent,compromised machine)



### 
