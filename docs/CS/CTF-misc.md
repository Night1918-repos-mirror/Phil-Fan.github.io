# MISC | 杂项

## 什么是MISC
miscellaneous 杂项

MISC = ALL - PWN - WEB - CRYPTO - REVERSE


一般来讲 misc 包括的题型：

- 隐写、取证、OSINT（信息搜集）、PPC（编程类） **—— 传统 misc 题**
- 游戏类题目（大概也算 PPC）、工具运用类题目
- 编解码、古典密码 **—— 不那么 crypto 的 crypto**
- 网络解谜、网站代码审计 **—— 不那么 web 的 web**
- 代码审计、沙箱逃逸 **—— 不那么 binary 的 binary**
- Blockchain、IoT、AI **—— 新兴类别题目**


## 编码分析
工具 

[Cyberchef](https://gchq.github.io/CyberChef/)/[TonyCrane ver.](https://lab.tonycrane.cc/CyberChef/)
[Base 系列爆破](https://github.com/mufeedvh/basecrack/)
[DenCode](https://dencode.com/)
[Ciphey](https://github.com/Ciphey/Ciphey)




所有信息都是01串，而01串之间可以发生互相的转换

常见的01串转换方式有 编解码、加解密、哈希

![](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/20240704135220.png)

### 字符编码
人类理解的字符 to 计算机理解的 01 串之间的映射

#### 乱码
用一种字符编码规则解读另一种字符编码的 01 串
![](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/20240704142921.png)

**常见乱码**

- 用 GBK 解码 UTF-8 编码的文本
- 用 UTF-8 解码 GBK 编码的文本
- 用 latin-1 解码 UTF-8 编码的文本
- 用 latin-1 解码 GBK 编码的文本
- 先用 GBK 解码 UTF-8 编码的文本，再用 UTF-8 解码前面的结果
- 先用 UTF-8 解码 GBK 编码的文本，再用 GBK 解码前面的结果

- `CyberChef`，通过 Input 和 Output 窗口的字符集设置
需要注意，CyberChef 的 UTF-8 不会将错误解码替换为 􀳦（非预期）
- `vscode` 右下角的编码方案（重新打开 / 用编码保存）
- 必要的时候可以使用 `python` 来进行编解码 / 进制转换等

#### `ASCII`
一共 128 个项，即每个字符可以用一个 7 位的 01 串表示（或一字节）
00-1F：控制字符；20-7E：可见字符；7F：控制字符（DEL）


#### `Latin-1`（ISO-8859-1）
扩展了 ASCII，一共 256 个项
80-9F：控制字符；A0-FF：可见字符
特点：任何字节流都可以用其解码

#### 利用 `Unicode` 字符集的一系列编码
UTF-8 / UTF-16 / UTF-32 / UCS

以平面划分，17 个平面，每个平面 65536 个码位（2 字节）
通过码位可以表示为 U+0000 ~ U+10FFFF

可容纳 111w+ 个字符，现有 14w+ 个字符（超过一半为 CJK 字符）

**UCS（Universal Character Set）**

`UCS-2`：直接用 2 字节表示码位；

`UCS-4`：直接用 4 字节表示码位

**UTF（Unicode Transformation Format）**：
- `UTF-8`：变长编码（1~4），兼容 ASCII
        0xxxxxxx
        110xxxxx 10xxxxxx
        1110xxxx 10xxxxxx 10xxxxxx
        11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
- `UTF-16`：变长编码（2/4），不兼容 ASCII


#### 中国国标字符集系列编码
GB 2312 / GBK / GB 18030-2022


### Base编码
!!! note "本质"
    字节流 -> 整数 -> n 进制 -> 系数查表

#### Base 16
base16编码也称为十六进制编码或Hex编码，是一种将二进制数据表示为十六进制数字和字符的方法。它使用16个字符（0-9和A-F）来表示4位二进制数的每个组合。

这里就涉及一个字节序的问题：是用大端模式还是小端模式？Base16编码明确表明是用小端模式存储。

编码过程：

1.将二进制数据分割为4个一组

2.映射，将每四位二进制数据映射到对应的base16字符。如下：

```

0000 -> 0
0001 -> 1
0010 -> 2
0011 -> 3
0100 -> 4
0101 -> 5
0110 -> 6
0111 -> 7
1000 -> 8
1001 -> 9
1010 -> A
1011 -> B
1100 -> C
1101 -> D
1110 -> E
1111 -> F
```
#### base32
由于5bit就可以表示2^5 = 32个字符。

结果长度必须是 5 的倍数，不足的用 = 不齐（明显特征）

```
00000 -> A
00001 -> B
00010 -> C
00011 -> D
00100 -> E
00101 -> F
00110 -> G
00111 -> H
01000 -> I
01001 -> J
01010 -> K
01011 -> L
01100 -> M
01101 -> N
01110 -> O
01111 -> P
10000 -> Q
10001 -> R
10010 -> S
10011 -> T
10100 -> U
10101 -> V
10110 -> W
10111 -> X
11000 -> Y
11001 -> Z
11010 -> 2
11011 -> 3
11100 -> 4
11101 -> 5
11110 -> 6
11111 -> 7
```


#### base58
原理：

- 准备要编码的二进制数据： 将要编码的二进制数据准备好，通常是字节的形式。

- 添加版本前缀（可选）： 在某些应用中，可以在二进制数据前添加一个版本前缀，以标识数据的类型或用途。这是可选的步骤，具体取决于编码的需求。

- 计算校验和（可选）： 在某些情况下，可以计算二进制数据的校验和并附加到数据的末尾，以增加数据的完整性和安全性。这也是可选的步骤。

- **Base58编码**： 将经过前两步（添加版本前缀和计算校验和，如果适用）的二进制数据转换为Base58编码的文本。编码过程如下：

Base58字符集通常包括58个字符，通常是由除去易混淆的字符（如0、O、I和l）以及可能引起歧义的字符（如+和/）的字符集构成。
将二进制数据视为一个大整数，使用Base58字符集中的字符作为数字的基数。

将大整数除以58，记录余数，并继续除以58，直到商为零。这将生成Base58编码的每个字符。

最后，反转生成的字符顺序以获得最终的Base58编码字符串。



#### base64
**明显特征**

结果长度必须是 4 的倍数，不足的用 = 不齐（1~2 个，明显特征）

**字符表**

标准字符表：`A-Za-z0-9+/`
另有多种常用字符表，如 URL 安全字符表：`A-Za-z0-9-_`


|  Index  |  Character  |  Index  |  Character  |  Index  |  Character  |  Index  |  Character  |
|:-------:|:-----------:|:-------:|:-----------:|:-------:|:-----------:|:-------:|:-----------:|
|    0    |      A      |   16    |      Q      |   32    |      g      |   48    |      w      |
|    1    |      B      |   17    |      R      |   33    |      h      |   49    |      x      |
|    2    |      C      |   18    |      S      |   34    |      i      |   50    |      y      |
|    3    |      D      |   19    |      T      |   35    |      j      |   51    |      z      |
|    4    |      E      |   20    |      U      |   36    |      k      |   52    |      0      |
|    5    |      F      |   21    |      V      |   37    |      l      |   53    |      1      |
|    6    |      G      |   22    |      W      |   38    |      m      |   54    |      2      |
|    7    |      H      |   23    |      X      |   39    |      n      |   55    |      3      |
|    8    |      I      |   24    |      Y      |   40    |      o      |   56    |      4      |
|    9    |      J      |   25    |      Z      |   41    |      p      |   57    |      5      |
|   10    |      K      |   26    |      a      |   42    |      q      |   58    |      6      |
|   11    |      L      |   27    |      b      |   43    |      r      |   59    |      7      |
|   12    |      M      |   28    |      c      |   44    |      s      |   60    |      8      |
|   13    |      N      |   29    |      d      |   45    |      t      |   61    |      9      |
|   14    |      O      |   30    |      e      |   46    |      u      |   62    |      +      |
|   15    |      P      |   31    |      f      |   47    |      v      |   63    |      /      |

**步骤**
1. 准备要编码的二进制数据： 将要编码的二进制数据准备好，通常是字节的形式。

2. 分组： 将二进制数据分成固定大小的组，每组通常为3字节（24位）。如果最后一组不足3字节，通常需要进行填充，以便每组都有3字节。

3. 将每个组的二进制数据转换为十进制： 将每个3字节的二进制数据视为一个8bit*3=24bit位的二进制整数，再转化为一个十进制整数。

4. Base64编码： 将每个十进制整数编码为Base64字符。

- Base64字符集通常包括64个字符，通常是大写字母A到Z、小写字母a到z、数字0到9以及两个额外的字符（通常是"+"和"/"）。
- 以24位整数为例，将它分成4组，每组6位。这4组6位整数将被编码为4个Base64字符。
- 每个6位整数对应一个Base64字符，根据其在Base64字符集中的位置来选择。
- 如果原始数据不足3字节，会添加一个或两个额外的0位，以确保每个6位整数都有6位。
- Base64编码的结果是一个文本字符串，其中包含一系列Base64字符，每4个字符分为一组，每组表示一个24位整数。
5. 填充（可选）： 如果原始数据的长度不是3的倍数，可以使用一个或两个填充字符“=”来补全Base64编码，以确保编码长度是4的倍数。


```python
import base64
 
str1 = "cPQebAcRp+n+ZeP+YePEWfP7bej4YefCYd/7cuP7WfcPb/URYeMRbesObi/=" # 待解密的base64编码
 
string1 = "LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK"    #替换的表
string2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
 
print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))
```


#### 总结
base家族编码都不算难，根据特征特点找到对应的加解密方式就可以了。下面总结一下各个base编码的特点。

- base16特征：由大写字母（A-Z）和数字（0-9）组成，通常不需要“=”填充

- base32特征：由大写字母（A-Z）和数字（2-7）组成，需要“=”填充

- base64特征：大小写字母（a-Z）和数字（0-9）以及特殊字符（'+','/'）不满3的倍数用“=”补齐，结尾有少量等号

- base58特征：同base64相比，少了数字‘0’和字母‘O'数字’1‘和字母’I‘以及'+'和'/'符号,也没有“=”

- base85特征：有很多奇怪的符号，但一般没有“=”

- base91特征：由91个字符（0-9，a-z，A-Z,!#$%&()*+,./:;<=>?@[]^_`{|}~”）组成

- base100特征：全是emoji表情。

### 其他编码

- UUencode、XXencode
- QR Code 二维码：[介绍](note.tonycrane.cc/ctf/misc/qrcode)
- 条形码
- 盲文编码
- 一些其他好玩的类编码：
  - 北约音标字母
  - 地点三词编码 [What3Words](https://what3words.com/)


## 信息搜集 | OSINT


Open Source INTelligence | 公开信息情报

[Information Protection & OSINT resources](https://github.com/ffffffff0x/Digital-Privacy?tab=readme-ov-file)


!!! bug "Don't be evil"


### 构造了一个全新的虚拟身份

sherlock:https://github.com/sherlock-project/sherlock
namechk:https://namechk.com/



### 图片、文档等附件泄漏


一些常用的搜索引擎：
- 百度识图搜索：中文互联网图片搜索结果
- Google 图片搜索：用来搜索外国范围的图片
- Bing 图片搜索：和 Google 差不多，都可以参考
- Yandex 图片搜索：搜索相似图片;搜索风景时更常用
- TinEye：搜索完全相同的图片（找来源）


---
**图片信息**
注意图片中的文字、牌匾、标志性建筑等，可用来作为关键词搜索

如果图片中关键信息较少，可以优先考虑使用搜索引擎识图
2023

- 太阳角度、阴影长度等太阳相关
  - https://www.suncalc.org/
  - https://www.sunearthtools.com/cn/index.php
        时间 <=> 位置互相估计
- 天气信息、云层信息等
- 飞机航班信息
  - https://flightaware.com/
- 估计方向，位置，时间等
- 风景信息 -> Yandex 搜索

---

**文档信息泄露**

- 各种文档的元信息（metadata）可能包括作者、修改时间等信息
  - 图片的 EXIF 信息，可通过 exiftool 查看
  - 一般以 xml 形式存储，可以直接通过二进制抹除，或者通过操作系统

- 工程文件夹泄漏信息
  - Visual Studio 的各种配置文件，`.vs` 文件夹中信息
  - `.vscode` 文件夹中的配置文件
  - `.git` 文件夹，泄漏全部修改历史、提交信息、提交者等

- 文件夹路径信息泄漏
  - `.DS_Store` 文件，macOS 下的文件夹布局信息
  - 前面各种工程配置文件等也会泄漏（比如 vs 的 pdb 调试信息）
  - markdown 文件图片路径（本地路径 / 图床用户 / 自建图床网站）



## 图片隐写
### LSB图片隐写

LSB全称为 least significant bit，是最低有效位的意思


## 压缩包分析

