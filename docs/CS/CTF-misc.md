# MISC | 杂项

## 什么是MISC
miscellaneous 杂项

MISC = ALL - PWN - WEB - CRYPTO - REVERSE


一般来讲 misc 包括的题型：

- 隐写、取证、OSINT（信息搜集）、PPC（编程类） **—— 传统 misc 题**
- 游戏类题目（大概也算 PPC）、工具运用类题目
- 编解码、古典密码 **—— 不那么 crypto 的 crypto**
- 网络解谜、网站代码审计 **—— 不那么 web 的 web**
- 代码审计、沙箱逃逸 **—— 不那么 binary 的 binary**
- Blockchain、IoT、AI **—— 新兴类别题目**


## 编码分析
工具 

[Cyberchef](https://gchq.github.io/CyberChef/)/[TonyCrane ver.](https://lab.tonycrane.cc/CyberChef/)
[Base 系列爆破](https://github.com/mufeedvh/basecrack/)
[DenCode](https://dencode.com/)
[Ciphey](https://github.com/Ciphey/Ciphey)




所有信息都是01串，而01串之间可以发生互相的转换

常见的01串转换方式有 编解码、加解密、哈希

![](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/20240704135220.png)

### 字符编码
[为什么会乱码？什么是编解码？ASCII、Unicode、UTF-8的实现原理是什么？本文帮你讲透！](https://yuanjava.com/characters-and-encodings/)


人类理解的字符 to 计算机理解的 01 串之间的映射

![](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/20240704142921.png)


#### 乱码
用一种字符编码规则解读另一种字符编码的 01 串



- `CyberChef`，通过 Input 和 Output 窗口的字符集设置
需要注意，CyberChef 的 UTF-8 不会将错误解码替换为 􀳦（非预期）
- `vscode` 右下角的编码方案（重新打开 / 用编码保存）
- 必要的时候可以使用 `python` 来进行编解码 / 进制转换等


**常见乱码**

=== "用 GBK 解码 UTF-8 编码的文本"

    “国”字的 Unicode是 U+56FD，在 UTF-8中，它被编码为三个字节：11100101 10011011 10011101 (0xE5 0x9B 0xBD)

    使用 GBK编码读取，它是一种双字节编码方案，因此，它可能会将这三个字节解释为两种：

    - 解释成 2个字节 + 1个字节，导致乱码。
    - 解释成 2个字节 + 2个字节(包含下一个字符的第一个字节)，导致乱码。

!!! note "ASCII字符是不会乱码的"
    因为所有的编码方案都是以 ASCII为基础的，ASCII字符在所有的编码方案中都是一样的，不会发生乱码。
    经常乱码的是有CJK字符的文本（Chinese，Japanese，Korean）


我们以"于是转身向大海走去"这句话为例，用不同的编码方式进行编码和解码，会产生不同的乱码形式。

| 名称 | 示例 | 特点 | 产生原因 |
| --- | --- | --- | --- |
| 古文码 | 浜庢槸杞韩鍚戝ぇ娴疯蛋鍘�  | 大部分为不认识的古文，并加杂日韩文 | 以GBK方式读取UTF-8编码的中文,GBK是双字节编码方案，会有识别不到的字符（缺字节） |
| 口字码 | ����ת�������ȥ | 大部分字符为小方块 | 以UTF-8的方式读取GBK编码的中文 |
| 符号码 | äºæ¯è½¬èº«åå±±æµ·èµ°å» | 大部分字符为各种符号 | 以ISO8859-1方式读取UTF-8编码的中文 |
| 拼音码 | ÓÚÊÇ×ªÉíÏòÉ½º£×ßÈ¥| 大部分字符为头尾带有类似声调符号的字母 | 以ISO8859-1方式读取 GBK编码的中文 |
| 问号码 | 于是转身向山海走�? | 字符长度为偶数时正确，长度为奇数时最后的字符变为问号 | 以GBK方式读取UTF-8编码的中文，然后用 UTF-8的格式再次读取 |
| 锟斤拷码 | 锟斤拷锟斤拷转锟斤拷锟斤拷山锟斤拷锟斤拷去 | 全中文字符，且大部分字符为“锟斤拷”这几个字 | 先用 UTF-8 解码 GBK 编码的文本，再用 GBK 解码前面的结果 |

这些乱码形式都是由于不同字符编码之间的转换错误造成的。在处理文本时，需要明确字符编码，并使用正确的编码进行转换，以避免出现乱码现象。


#### ASCII
> ASCII码是为了英语使用者能够把常用的 128个字符存储在计算机中而设置的一套规则。

（American Standard Code for Information Interchange，美国标准信息交换码）：总共 128个字符，包括英文字母、数字、一些特殊符号和控制字符

一共 128 个项，即每个字符可以用一个 7 位的 01 串表示（或一字节）
00-1F：控制字符；20-7E：可见字符；7F：控制字符（DEL）




![](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/20240704180429.png)


#### Latin-1（ISO-8859-1）
扩展了 ASCII，一共 256 个项
80-9F：控制字符；A0-FF：可见字符
特点：任何字节流都可以用其解码

#### 利用 Unicode 字符集的一系列编码
Unicode，正如它的中文意思“统一码”一样，它包含了世界上所有的通用符号（超过 110多万个符号），而且给每个符号赋予一个独一无二的编码，通常表示为：`U+`后跟一个十六进制数，例如，`U+56fd `表示汉字的“国”，`U+0639` 表示阿拉伯字母 Ain，`U+0041` 表示英语的字母 A等。


**UTF-8 / UTF-16 / UTF-32 / UCS**

以平面划分，17 个平面，每个平面 65536 个码位（2 字节）
通过码位可以表示为 U+0000 ~ U+10FFFF

可容纳 111w+ 个字符，现有 14w+ 个字符（超过一半为 CJK 字符）

**UCS（Universal Character Set）**

`UCS-2`：直接用 2 字节表示码位；

`UCS-4`：直接用 4 字节表示码位

**UTF（Unicode Transformation Format）**：
- `UTF-8`：变长编码（1~4），兼容 ASCII
        

=== "可变长度"

    1 字节: 用于编码 7 位 ASCII 字符，表示范围：U+0000 到 U+007F，与 ASCII 码完全兼容
    2 字节: 用于编码 11 位字符，表示范围：U+0080 到 U+07FF
    3 字节: 用于编码 16 位字符，表示范围：U+0800 到 U+FFFF
    4 字节: 用于编码 21 位字符，表示范围：U+10000 到 U+10FFFF

=== "编码规则"

    - 对于单字节的符号，UTF-8编码和 ASCII码是相同的：第一位为 0，后面 7位为 Unicode码
    - 对于$n(n >= 2)$字节的符号，二进制的第一个字节，最高位有 n个1（1后面紧跟一位 0），二进制后面的每个字节，前两位都固定为“10”，xxx部分全部是 Unicode码
  
    1 字节: 0xxxxxxx
    2 字节: 110xxxxx 10xxxxxx
    3 字节: 1110xxxx 10xxxxxx 10xxxxxx
    4 字节: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

=== "示例"

    1. 字符A(U+0041)
    分析：字符’A’的 Unicode是 U+0041，位于 U+0000 到 U+007F之间，因此，一个字节就可以表示，因此，二进制为：01000001，转成十六进制为：0x41

    2. 字符€ (U+20AC)
    分析：字符 ‘€’的 Unicode是 U+20AC，位于 U+0800 到 U+FFFF之间，因此，需要用 3个字节表示，即1110xxxx 10xxxxxx 10xxxxxx，将“20AC”中的每个字符直接转换成二进制为：0010 0000 1010 1100，然后将它从低位往高位（从右到左）依次替换x，如下图：
    ![](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/20240704183246.png)
    这样得出字符 € (U+20AC)用 UTF-8编码的二进制为：11100010 10000010 10101100，转换成十六进制为：0xE2 0x82 0xAC


- `UTF-16`：变长编码（2/4），不兼容 ASCII


#### 中国国标字符集系列编码
GB 2312 / GBK / GB 18030-2022

**GB2312**

ASCII码的设计很优秀，但对于中文使用者，怎么能接受计算机存储不了中文的现实？于是，聪明的中国人在 1980年发布了一套适用自己的新编准：GB2312。

GB2312 是中华人民共和国国家标准《信息交换用汉字编码字符集 基本集》的简称，全称为 GB 2312-1980。该标准定义了用于简体中文字符和一些其他字符的编码方法，而且兼容 ASCII，广泛应用于中文信息处理系统中。

=== "字符范围"
    GB2312是一个**双字节编码字符集**,总共有 7445个字符，主要包括 6763个汉字和 682个非汉字字符（如 ASCII、拉丁字母、希腊字母、日文假名、符号等）。具体分为以下两个部分：

    - 一级汉字：3755个常用汉字，按拼音顺序排列
    - 二级汉字：3008个次常用汉字，按部首/笔画顺序排列
    - 非汉字字符：682个，包括图形符号、拉丁字母、日文假名、希腊字母、俄文字母、制表符、标点符号等。

=== "编码区间"

    GB2312 将字符集划分为 94个区（1-94），每区包含 94个位置（1-94）
    每个字符由两个字节表示，第一个字节（高字节）表示区号，第二个字节（低字节）表示位置号
    第一个字节范围：0xA1 - 0xF7
    第二个字节范围：0xA1 - 0xFE


    高字节：0xA1 + 区号 - 1
    低字节：0xA1 + 位置号 - 1

    “你”在 GB2312编码表中位于第 36区第 67位：
    ```
    高字节：0xA1 + 36 - 1 = 0xC4
    低字节：0xA1 + 67 - 1 = 0xE3
    因此，"你"的 GB2312编码为 0xC4E3，和 GB2312编码表中的值可以对应上。
    ```

**GBK**

随着互联网的快速发展，GB2312编码表中定义的字符已经不够用了，因此，GB2312的扩展版 GBK编码表诞生了。

GBK是“**国标扩**展字符集”前 3个汉字拼音首字母的缩写，全称是《汉字内码扩展规范》（Chinese Internal Code Extension, GBK）。GBK字符集是 1993年发布的，它是对 GB2312的扩展。

GBK是一个**双字节编码字符集**，每个字符由一个或两个字节表示。其编码结构如下：

=== "字符范围"

    GBK支持 21003个汉字和图形字符，涵盖了汉字、日文假名、韩文、特殊符号等
    包括 GB2312的全部字符，以及其他新增的汉字和符号

=== "编码区间"

    GBK扩展了 GB2312的编码范围，使其支持更多字符
    单字节部分（与 ASCII兼容）：0x00 - 0x7F
    
    双字节部分：
    第一个字节范围：0x81 - 0xFE
    第二个字节范围：0x40 - 0xFE（去掉 0x7F）

=== "编码示例"

    单字节
    字符“A”，使用单个字节可以存储，“A”的 ASCII码十进制是65，转换成十六进制为:0x41，二进制为：1000001

    双字节
    字符“汉”在 GBK编码中使用双字节表示，GBK编码: BABA，分成两个字节表示成：0xBA 0xBA


**GB18030**

GB18030 是国家标准化委员会（SAC）发布的字符编码标准，是一种用于汉字、汉语拼音、注音符号和汉字部首等文字的字符集和编码方案，它是继 GB2312和 GBK 后更强劲的版本。

GB18030的特点包括：

- 兼容性：GB18030兼容ASCII、GB2312、GBK以及Unicode等多种编码方案。
- 完备性：GB18030收录了70000多个字符，包括汉字、汉语拼音、注音符号、汉字部首、拉丁字母、数字、标点符号等。
- 可扩展性：GB18030采用了四字节编码方案，可以容纳未来出现的所有字符。其中汉字使用双字节或四字节编码，而非汉字字符则使用单字节或双字节编码。

### Base编码
!!! note "本质"
    字节流 -> 整数 -> n 进制 -> 系数查表

#### Base 16
base16编码也称为十六进制编码或Hex编码，是一种将二进制数据表示为十六进制数字和字符的方法。它使用16个字符（0-9和A-F）来表示4位二进制数的每个组合。

这里就涉及一个字节序的问题：是用大端模式还是小端模式？Base16编码明确表明是用小端模式存储。

编码过程：

1.将二进制数据分割为4个一组

2.映射，将每四位二进制数据映射到对应的base16字符。如下：

```

0000 -> 0
0001 -> 1
0010 -> 2
0011 -> 3
0100 -> 4
0101 -> 5
0110 -> 6
0111 -> 7
1000 -> 8
1001 -> 9
1010 -> A
1011 -> B
1100 -> C
1101 -> D
1110 -> E
1111 -> F
```
#### base32
由于5bit就可以表示2^5 = 32个字符。

结果长度必须是 5 的倍数，不足的用 = 不齐（明显特征）

```
00000 -> A
00001 -> B
00010 -> C
00011 -> D
00100 -> E
00101 -> F
00110 -> G
00111 -> H
01000 -> I
01001 -> J
01010 -> K
01011 -> L
01100 -> M
01101 -> N
01110 -> O
01111 -> P
10000 -> Q
10001 -> R
10010 -> S
10011 -> T
10100 -> U
10101 -> V
10110 -> W
10111 -> X
11000 -> Y
11001 -> Z
11010 -> 2
11011 -> 3
11100 -> 4
11101 -> 5
11110 -> 6
11111 -> 7
```


#### base58
原理：

- 准备要编码的二进制数据： 将要编码的二进制数据准备好，通常是字节的形式。

- 添加版本前缀（可选）： 在某些应用中，可以在二进制数据前添加一个版本前缀，以标识数据的类型或用途。这是可选的步骤，具体取决于编码的需求。

- 计算校验和（可选）： 在某些情况下，可以计算二进制数据的校验和并附加到数据的末尾，以增加数据的完整性和安全性。这也是可选的步骤。

- **Base58编码**： 将经过前两步（添加版本前缀和计算校验和，如果适用）的二进制数据转换为Base58编码的文本。编码过程如下：

Base58字符集通常包括58个字符，通常是由除去易混淆的字符（如0、O、I和l）以及可能引起歧义的字符（如+和/）的字符集构成。
将二进制数据视为一个大整数，使用Base58字符集中的字符作为数字的基数。

将大整数除以58，记录余数，并继续除以58，直到商为零。这将生成Base58编码的每个字符。

最后，反转生成的字符顺序以获得最终的Base58编码字符串。



#### base64
**明显特征**

结果长度必须是 4 的倍数，不足的用 = 不齐（1~2 个，明显特征）

**字符表**

标准字符表：`A-Za-z0-9+/`
另有多种常用字符表，如 URL 安全字符表：`A-Za-z0-9-_`


|  Index  |  Character  |  Index  |  Character  |  Index  |  Character  |  Index  |  Character  |
|:-------:|:-----------:|:-------:|:-----------:|:-------:|:-----------:|:-------:|:-----------:|
|    0    |      A      |   16    |      Q      |   32    |      g      |   48    |      w      |
|    1    |      B      |   17    |      R      |   33    |      h      |   49    |      x      |
|    2    |      C      |   18    |      S      |   34    |      i      |   50    |      y      |
|    3    |      D      |   19    |      T      |   35    |      j      |   51    |      z      |
|    4    |      E      |   20    |      U      |   36    |      k      |   52    |      0      |
|    5    |      F      |   21    |      V      |   37    |      l      |   53    |      1      |
|    6    |      G      |   22    |      W      |   38    |      m      |   54    |      2      |
|    7    |      H      |   23    |      X      |   39    |      n      |   55    |      3      |
|    8    |      I      |   24    |      Y      |   40    |      o      |   56    |      4      |
|    9    |      J      |   25    |      Z      |   41    |      p      |   57    |      5      |
|   10    |      K      |   26    |      a      |   42    |      q      |   58    |      6      |
|   11    |      L      |   27    |      b      |   43    |      r      |   59    |      7      |
|   12    |      M      |   28    |      c      |   44    |      s      |   60    |      8      |
|   13    |      N      |   29    |      d      |   45    |      t      |   61    |      9      |
|   14    |      O      |   30    |      e      |   46    |      u      |   62    |      +      |
|   15    |      P      |   31    |      f      |   47    |      v      |   63    |      /      |

**步骤**
1. 准备要编码的二进制数据： 将要编码的二进制数据准备好，通常是字节的形式。

2. 分组： 将二进制数据分成固定大小的组，每组通常为3字节（24位）。如果最后一组不足3字节，通常需要进行填充，以便每组都有3字节。

3. 将每个组的二进制数据转换为十进制： 将每个3字节的二进制数据视为一个8bit*3=24bit位的二进制整数，再转化为一个十进制整数。

4. Base64编码： 将每个十进制整数编码为Base64字符。

- Base64字符集通常包括64个字符，通常是大写字母A到Z、小写字母a到z、数字0到9以及两个额外的字符（通常是"+"和"/"）。
- 以24位整数为例，将它分成4组，每组6位。这4组6位整数将被编码为4个Base64字符。
- 每个6位整数对应一个Base64字符，根据其在Base64字符集中的位置来选择。
- 如果原始数据不足3字节，会添加一个或两个额外的0位，以确保每个6位整数都有6位。
- Base64编码的结果是一个文本字符串，其中包含一系列Base64字符，每4个字符分为一组，每组表示一个24位整数。
5. 填充（可选）： 如果原始数据的长度不是3的倍数，可以使用一个或两个填充字符“=”来补全Base64编码，以确保编码长度是4的倍数。


```python
import base64
 
str1 = "cPQebAcRp+n+ZeP+YePEWfP7bej4YefCYd/7cuP7WfcPb/URYeMRbesObi/=" # 待解密的base64编码
 
string1 = "LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK"    #替换的表
string2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
 
print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))
```


#### 总结
base家族编码都不算难，根据特征特点找到对应的加解密方式就可以了。下面总结一下各个base编码的特点。

- base16特征：由大写字母（A-Z）和数字（0-9）组成，通常不需要“=”填充

- base32特征：由大写字母（A-Z）和数字（2-7）组成，需要“=”填充

- base64特征：大小写字母（a-Z）和数字（0-9）以及特殊字符（'+','/'）不满3的倍数用“=”补齐，结尾有少量等号

- base58特征：同base64相比，少了数字‘0’和字母‘O'数字’1‘和字母’I‘以及'+'和'/'符号,也没有“=”

- base85特征：有很多奇怪的符号，但一般没有“=”

- base91特征：由91个字符（0-9，a-z，A-Z,!#$%&()*+,./:;<=>?@[]^_`{|}~”）组成

- base100特征：全是emoji表情。

### 其他编码

- UUencode、XXencode
- QR Code 二维码：[介绍](note.tonycrane.cc/ctf/misc/qrcode)
- 条形码
- 盲文编码
- 一些其他好玩的类编码：
  - 北约音标字母
  - 地点三词编码 [What3Words](https://what3words.com/)


## 信息搜集 | OSINT


Open Source INTelligence | 公开信息情报

[Information Protection & OSINT resources](https://github.com/ffffffff0x/Digital-Privacy?tab=readme-ov-file)


!!! bug "Don't be evil"


### 构造了一个全新的虚拟身份

sherlock:https://github.com/sherlock-project/sherlock
namechk:https://namechk.com/



### 图片、文档等附件泄漏


一些常用的搜索引擎：
- 百度识图搜索：中文互联网图片搜索结果
- Google 图片搜索：用来搜索外国范围的图片
- Bing 图片搜索：和 Google 差不多，都可以参考
- Yandex 图片搜索：搜索相似图片;搜索风景时更常用
- TinEye：搜索完全相同的图片（找来源）


---
**图片信息**
注意图片中的文字、牌匾、标志性建筑等，可用来作为关键词搜索

如果图片中关键信息较少，可以优先考虑使用搜索引擎识图
2023

- 太阳角度、阴影长度等太阳相关
  - https://www.suncalc.org/
  - https://www.sunearthtools.com/cn/index.php
        时间 <=> 位置互相估计
- 天气信息、云层信息等
- 飞机航班信息
  - https://flightaware.com/
- 估计方向，位置，时间等
- 风景信息 -> Yandex 搜索

几何学信息解算楼层
[如何根据一张照片判断出女孩住在几层楼？](https://blog.csdn.net/hzp666/article/details/81458857)

[【实战类】根据图片信息寻找具体楼层](https://cn-sec.com/archives/950750.html)

---

**文档信息泄露**

- 各种文档的元信息（metadata）可能包括作者、修改时间等信息
  - 图片的 EXIF 信息，可通过 exiftool 查看
  - 一般以 xml 形式存储，可以直接通过二进制抹除，或者通过操作系统

- 工程文件夹泄漏信息
  - Visual Studio 的各种配置文件，`.vs` 文件夹中信息
  - `.vscode` 文件夹中的配置文件
  - `.git` 文件夹，泄漏全部修改历史、提交信息、提交者等

- 文件夹路径信息泄漏
  - `.DS_Store` 文件，macOS 下的文件夹布局信息
  - 前面各种工程配置文件等也会泄漏（比如 vs 的 pdb 调试信息）
  - markdown 文件图片路径（本地路径 / 图床用户 / 自建图床网站）



## 图片隐写
### LSB图片隐写

LSB全称为 least significant bit，是最低有效位的意思


## 压缩包分析

