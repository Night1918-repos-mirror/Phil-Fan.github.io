# 传输层 | `Transport Layer`

## 原理

进程与进程之间 以message为单位的通讯

### 复用、解复用

段 段的头部取出来

字节流的服务，不保证段与段之间的标识

传输协议运行在端系统
发送方：将应用层的报文分成报文段，然后传递给网络层
接收方：将报文段重组成报文，然后传递给应用层

### 可靠

IP是不可靠的，TCP可以变成可靠的

传输层使用同一个socket为指定的台做传输

> 两个家庭互相寄信的例子
>
> 把源端的信件一团交给postman
>
> 送到目标邮箱，从信箱里吧信件分装 -->解复用

### 流量控制

一个点到另一个点





### 拥塞控制





## 协议 Protocol

### UDP

**User Datagram Protocol [RFC 768]（用户数据报协议）**

实时性

可靠性和实时性的对立统一

无连接、不可靠、无流量控制、无拥塞控制

如：实时的 流媒体、远程会议、DNS

不需要握手，头部占比小开销小，简单



应用于：

 流媒体（丢失不敏感，速率敏感、应用可控制传输速率）
 DNS
 SNMP



EDC

#### 格式

1. 8字节**头部**——2字节源端口号、2字节目的端口号、数据长度（包括头部）、校验和EDC。
2. **报文部分**——校验和出错后全部丢掉。

以`datagram`为单位

- 源ip + port 

- 发送报文

- 目标ip + port

<img src="https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240130231654238.png" alt="image-20240130231654238" style="zoom:50%;" />



细分网络层的服务 

变成进程到进程

不可靠变成了可靠

![image-20240130231125338](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240130231125338.png)

#### UDP校验和

发送方：

- 将报文段的内容视为16比特的整数
- 校验和：报文段的加法和（1的补运算）
- 发送方将校验和放在

接收方：

- 计算接收到的报文段的校验和

- 检查计算出的校验和与校验和字段的内容是否相等：

  - 不相等–--检测到差错

  - 相等–--没有检测到差错，但也许还是有差错残存错误

注意：当数字相加时，在最高位的进位要回卷，再加
到结果上



??? bug
    发送方取反
    校验范围+校验和
    如果结果16bit全是1，则不出现错误；否则出现错误


### TCP

传输控制协议 **reliable:不重复、不乱序、不丢失、不出错**

runtrip time

`packet`为单位

`socket`是一个整数 记录四元组：本地ip+port 对方ip+port 进程PID



message + 本地port + 对方 port 形成TCP数据报

再加上本地 ip + 对方ip 形成IP数据报文

-  复用

![image-20240130220235305](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240130220235305.png)

- 解复用

![image-20240130230254626](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240130230254626.png)



![image-20240130231052510](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240130231052510.png)

有流量控制和拥塞控制 

如：HTTP、FTP、Telnet、SMTP



#### RDT 可靠数据传递

在下层服务不可靠的情况下，向上保证可靠

![image-20240130233920207](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240130233920207.png)

FSM 有限状态机

引起状态变迁的事件 and 状态变迁时采取的动作

相应和激励

上层元语+本层动作+下层服务

- Rdt1.0: 在可靠信道上的可靠数据传输

下层信道完全可靠

发送方和接收方的FSM
 发送方将数据发送到下层信道
 接收方从下层信道接收数据



- Rdt2.0：具有比特差错的信道

下层信道可能会出错：将分组中的比特翻转（01互换）、用校验和来检测

<img src="https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240131000805343.png" alt="image-20240131000805343" style="zoom:50%;" />

问题：怎样从差错中恢复：

确认(ACK)：接收方确认 - 什么都不做
否定确认( NAK): 接收方声明出错，发送方重传分组

- rdt2.1 ACK/NAK出错（停等协议

加入分组序号

对于发送方：每个分组中加入序号，不是ACK就重新发

接受方：检验和正确发送ACK，再判断序号；检验和错误发送NAK

!!! note
	用一位表示分组的序号
	没有确认的确认，如果下一次传了不同的分组，说明确认已经被发送方收到

- rdt2.2：FREE NAK 无NAK的协议

> 郑老师有趣的例子：
>
> ：你说这个人漂不漂亮
>
> ：她很老实

对ACK做编号，对前一个分组ACK相当于当前分组反向确认



- rdt3.0：具有比特差错和分组丢失的信道

发送方**超时重传**

重传时间略大约正常往返的时间

停等协议在信道容量大的时候效率较低

> 理解
> 合肥到北京高速公路：一个车过了到了北京才允许下一个车进入高速；但高速可以容纳很多车

adaptive 动态超时时间设置：过早超时可以运行，但效率低

![image-20240131010457267](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240131010457267.png)

流水线协议

未得到对方确认，不停打分组，用多个bit表示分组



回退N步(GBN)和选择重传(SR)



滑动窗口(slide window)协议

| 发送缓冲区 |        | 协议名称         | 最大n     |
| ---------- | ------ | ---------------- | --------- |
| SW = 1     | RW = 1 | stop and waiting |           |
| SW > 1     | RW = 1 | GBN              | $2^n -1$  |
| SW > 1     | RW > 1 | SR               | $2^{n-1}$ |

发送缓冲区
 形式：内存中的一个区域，落入缓冲区的分组可以发送

发送窗口是发送缓冲区的一个子集

![image-20240131011636831](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240131011636831.png)

每发送一个分组，前沿前移一个单位

得到确认一个分组，后沿前移一个单位，不能够超过前沿

缓冲区大小：最大前沿-最小后沿



GBN go back n - 接收方缓冲区为1；顺序到来最高的发确认，累积确认；只维护一个定时器

SR selective repeat - 非累积确认；对到来的分组逐一确认；维护每一个点的定时器



异常情况

- 传送分组在传送中丢失或出错
- 接收方确认没有收到

GBN 回到最小次序的分组，go back 到没有确认的点，重新发送后续

SR 单独发送没有收到的

![image-20240131015308004](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240131015308004.png)

![image-20240131015418519](https://philfan-pic.oss-cn-beijing.aliyuncs.com/img/image-20240131015418519.png)

滑动窗口的滑动，低序号到来，高序号提前到来要缓存





适用范围
 出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理
 链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大

#### 拥塞控制

